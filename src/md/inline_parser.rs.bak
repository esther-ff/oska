use crate::md::{
    Walker,
    chars::{ASTERISK, BACKTICK, NEWLINE, UNDERSCORE},
};

use super::{
    Block, Document,
    blocks::{Parsed, Unparsed},
    inlines::{EmphasisChar, Inline, Inlines},
};

/// A trait representing a parser for inline elements
/// such as emphases or links.
pub trait InlineParser {
    fn parse(&mut self, item: Block<Unparsed>) -> Block<Parsed>;
    fn parse_doc(&mut self, doc: Document<Unparsed>) -> Document<Parsed>;
    fn parse_inlines(&mut self, src: &str) -> Inlines;
}

#[derive(Debug)]
struct Delim {
    char: DelimChar,
    amnt: usize,
    pos: (usize, usize),
    binding: Binding,
}

#[derive(Debug, PartialEq, PartialOrd, Ord, Eq)]
enum DelimChar {
    ExclBracket,
    Asterisk,
    Underscore,
    Tilde,
    Bracket,
    Newline,
    Parenthesis,
}

impl Delim {
    fn new(char: DelimChar, amnt: usize, start: usize, end: usize, binding: Binding) -> Self {
        Self {
            char,
            amnt,
            pos: (start, end),
            binding,
        }
    }

    fn close(&mut self) {
        self.binding = Binding::Closed;
    }

    fn as_str<'b>(&self, data: &'b str) -> Option<&'b str> {
        data.get(self.pos.0..self.pos.1)
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
enum Binding {
    None,
    Left,
    Right,
    Closed,
}

impl Binding {
    pub fn rev(&mut self) {
        *self = match *self {
            Binding::Left => Binding::Right,
            Binding::Right => Binding::Left,
            Binding::None => panic!("do not reverse none"),
            Binding::Closed => panic!("do not reverse close"),
        }
    }
}

/// Default parser for Inlines
pub struct DefInlineParser {}

fn delimeters(walker: &mut Walker) -> Vec<Delim> {
    let mut delims = Vec::new();

    while let Some(output) = walker.next() {
        match output {
            b'!' => {
                if walker.is_next_char(b'[') {
                    walker.advance(1);
                    delims.push(Delim {
                        char: DelimChar::ExclBracket,
                        binding: Binding::Left,
                        amnt: 1,
                        pos: (walker.position(), walker.position() + 1),
                    })
                }
            }

            b'~' => {
                let start = walker.position();
                let amnt = walker.till_not(b'~') + 1;
                let pos = (start, walker.position() + 1);

                delims.push(Delim {
                    char: DelimChar::Tilde,
                    amnt,
                    pos,
                    binding: Binding::None,
                })
            }

            b'[' => delims.push(Delim {
                char: DelimChar::Bracket,
                amnt: 1,
                pos: (walker.position(), walker.position() + 1),
                binding: Binding::Left,
            }),

            b'(' => delims.push(Delim {
                char: DelimChar::Parenthesis,
                amnt: 1,
                pos: (walker.position(), walker.position() + 1),
                binding: Binding::Left,
            }),

            b')' => delims.push(Delim {
                char: DelimChar::Parenthesis,
                amnt: 1,
                pos: (walker.position(), walker.position() + 1),
                binding: Binding::Right,
            }),

            b']' => delims.push(Delim {
                char: DelimChar::Bracket,
                amnt: 1,
                pos: (walker.position(), walker.position() + 1),
                binding: Binding::Right,
            }),

            ASTERISK => {
                let start = walker.position();
                let amnt = walker.till_not(ASTERISK) + 1;
                let pos = (start - 1, walker.position());

                delims.push(Delim {
                    char: DelimChar::Asterisk,
                    amnt,
                    pos,
                    binding: Binding::None,
                })
            }

            UNDERSCORE => {
                let start = walker.position();
                let amnt = walker.till_not(UNDERSCORE) + 1;
                let pos = (start - 1, walker.position());

                delims.push(Delim {
                    char: DelimChar::Underscore,
                    amnt,
                    pos,
                    binding: Binding::None,
                })
            }

            b'\n' => delims.push(Delim {
                char: DelimChar::Newline,
                amnt: 1,
                pos: (walker.position() - 1, walker.position()),
                binding: Binding::None,
            }),

            _ => {}
        }
    }

    delims
}

fn parse_inlines_private(
    inlines: &mut Vec<Inline>,
    delimeters: &mut [Delim],
    previous_pos: (usize, usize),
) -> bool {
    let mut iter = delimeters
        .iter_mut()
        .filter(|delim| delim.binding != Binding::Closed)
        .enumerate()
        .peekable();

    let (base_index, base) = match iter.next() {
        None => {
            inlines.push(Inline::text(previous_pos.0, previous_pos.1));
            return false;
        }
        Some((index, val)) => (index, val),
    };

    dbg!(&base);

    let mut maybes: Vec<&mut Delim> = Vec::new();

    while let Some((index, next)) = iter.next() {
        if base.char == next.char {
            match &base.char {
                cap @ (DelimChar::Asterisk | DelimChar::Underscore) => {
                    let char = match cap {
                        DelimChar::Asterisk => EmphasisChar::Asterisk,
                        DelimChar::Underscore => EmphasisChar::Underscore,

                        _ => unreachable!(),
                    };

                    let finished = iter.peek().is_some();
                    let even: bool;

                    match base.amnt.cmp(&next.amnt) {
                        core::cmp::Ordering::Equal => {
                            even = base.amnt % 2 == 0;

                            base.close();
                            next.close();
                        }

                        core::cmp::Ordering::Less => {
                            even = base.amnt % 2 == 0;
                            next.amnt -= base.amnt;
                            base.close();
                        }

                        core::cmp::Ordering::Greater => {
                            // base.amnt -= next.amnt;
                            // next.close();
                            //

                            even = next.amnt % 2 == 0;
                            dbg!((&base, &next));
                            maybes.push(next);

                            continue;

                            // panic!("was greater");
                        }
                    }

                    let pos = (base.pos.1 + 1, next.pos.0);

                    let emph = if even {
                        let mut val = Inline::emph(base.amnt > 1, char);

                        parse_inlines_private(
                            val.expose_inlines().unwrap(),
                            &mut delimeters[base_index..index],
                            pos,
                        );

                        val
                    } else {
                        let mut outer = Inline::emph(true, char);
                        let mut inner = Inline::emph(false, char);

                        parse_inlines_private(
                            inner.expose_inlines().unwrap(),
                            &mut delimeters[base_index..index],
                            pos,
                        );

                        outer.expose_inlines().map(|x| x.push(inner));

                        outer
                    };

                    inlines.push(emph);
                    return finished;
                }

                DelimChar::Tilde => {}
                DelimChar::Parenthesis => unreachable!(),
                DelimChar::Bracket => {
                    if next.binding == Binding::Right {
                        if iter.peek().is_some_and(|(_, val)| {
                            (val.char == DelimChar::Parenthesis) && val.binding == Binding::Left
                        }) {
                            let _esprit = iter.next();

                            if iter.peek().is_some_and(|(_, val)| {
                                val.char == DelimChar::Parenthesis && val.binding == Binding::Right
                            }) {}
                        }
                    }
                }
                DelimChar::Newline => {}
                DelimChar::ExclBracket => unreachable!(),
            }
        } else if base.char == DelimChar::ExclBracket && next.char == DelimChar::Bracket {
            todo!()
        }
    }

    println!("meow");
    inlines.push(Inline::text(previous_pos.0, previous_pos.1));

    true
}

fn parse_inlines_outer(inl: &mut Vec<Inline>, delimeters: &mut [Delim]) {
    parse_inlines_private(inl, delimeters, (0, 0));
}

impl DefInlineParser {}

impl InlineParser for DefInlineParser {
    fn parse_inlines(&mut self, src: &str) -> Inlines {
        let mut inl = Inlines::new();
        let mut walker = Walker::new(src);

        let mut delims = delimeters(&mut walker);

        // delims
        //     .iter()
        //     .map(|delim| delim.as_str(src))
        //     .for_each(|x| println!("{:#?}", x));

        parse_inlines_outer(inl.inner(), &mut delims);

        dbg!(&inl);

        inl
    }

    fn parse(&mut self, item: Block<Unparsed>) -> Block<Parsed> {
        todo!()
    }

    fn parse_doc(&mut self, doc: Document<Unparsed>) -> Document<Parsed> {
        todo!()
    }
}

#[cfg(test)]
mod tests {
    use super::DefInlineParser;
    use super::InlineParser;

    #[test]
    fn bold() {
        let data = "***__Sam_ple__***_\n";

        let mut parser = DefInlineParser {};

        let mut inl = parser.parse_inlines(data);

        // inl.iter_values(data)
        //     .into_iter()
        //     .for_each(|x| println!("{:#?}", x));
    }
}

// if delim.char == NEWLINE {
//                 inl.add(Inline::SoftBreak);
//                 continue;
//             }

//             let next_delim = match delim_iter.next() {
//                 Some(val) => val,
//                 None => break,
//             };

//             if delim.char == next_delim.char {
//                 if delim.amnt % 2 == 0 {
//                     let emph = if delim.amnt == usize::from(next_delim.amnt) {
//                         Inline::emph(
//                             true,
//                             EmphasisChar::from_u8(delim.char)
//                                 .expect("this char should always be an asterisk or underscore"),
//                             Inline::text(delim.pos.1, next_delim.pos.0 - 1),
//                         )
//                     } else {
//                         let emph_inner = Inline::emph(
//                             true,
//                             EmphasisChar::from_u8(delim.char)
//                                 .expect("this char should always be an asterisk or underscore"),
//                             Inline::text(delim.pos.1 + 1, next_delim.pos.0),
//                         );

//                         Inline::emph(
//                             false,
//                             EmphasisChar::from_u8(delim.char).unwrap(),
//                             emph_inner,
//                         )
//                     };

//                     inl.add(emph)
//                 } else {
//                     //
//                 }
//             }
// fn parse_one_inline(
//     &mut self,
//     slice: &mut [Delim],
//     old: (usize, usize),
//     inl: &mut Vec<Inline>,
//     inner: bool,
// ) -> bool {
//     let mut iter = slice
//         .iter_mut()
//         .filter(|x| x.binding != Binding::Closed)
//         .enumerate();

//     match iter.next() {
//         None => return false,
//         Some((first_index, val)) => {
//             dbg!(&val);
//             if val.char == '\n' {
//                 val.binding = Binding::Closed;
//                 inl.push(Inline::soft_break());
//                 return true;
//             }

//             while let Some((index, delim)) = iter.next() {
//                 if val.amnt == delim.amnt {
//                     if val.char == delim.char {
//                         let char = match delim.char {
//                             '*' => EmphasisChar::Asterisk,
//                             '_' => EmphasisChar::Underscore,
//                             _ => panic!("invalid"),
//                         };

//                         val.close();
//                         delim.close();

//                         let pos = (val.pos.0 + val.amnt, delim.pos.1 - delim.amnt);

//                         let mut emph = Inline::emph(val.amnt > 1, char);

//                         dbg!(&mut slice[first_index..index]);
//                         self.parse_one_inline(
//                             &mut slice[first_index..index],
//                             pos,
//                             emph.expose_inlines().unwrap(),
//                             true,
//                         );

//                         inl.push(emph);

//                         return true;
//                     }
//                 } else {
//                     delim.close();
//                 }
//             }

//             println!("cannons");
//             val.close();
//             inl.push(Inline::text(val.pos.0, val.pos.1 + 1))
//         }
//     };

//     true
// }
